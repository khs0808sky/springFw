# springFw

## 📅 목차

- [2025-07-21](#2025-07-21)
- [2025-07-22](#2025-07-22)

<br><br><br>

# 2025-07-21
---

## 1. XML 기반 의존성 주입 (Dependency Injection)

* **무엇인가?**
  객체 간의 의존 관계를 XML 파일에 설정해두고, 스프링 컨테이너가 이를 읽어 필요한 객체를 생성하고 연결해 주는 방식.

* **특징**

  * 모든 의존 관계를 XML 설정 파일에서 선언적으로 관리
  * 객체 생성과 주입 방식을 모두 설정 파일에서 제어
  * 생성자 주입과 세터 주입을 명확히 구분해서 설정 가능
  * 설정과 코드가 분리되어 있어 설정 변경 시 코드 수정 없이 의존성 변경 가능
  * 다만 설정이 길어지면 XML이 복잡해지고 관리가 어려울 수 있음

* **장점**

  * 설정이 한 곳에 집중되어 있어 의존성 흐름 파악이 용이
  * 환경별, 배포별 설정 변경이 쉬움
  * XML 파일만 바꾸면 의존성 변경 가능 → 유연성 높음

* **단점**

  * XML 작성과 관리에 번거로움
  * 코드와 설정이 분리돼 있어 개발 중 이해가 어려울 수 있음
  * 자바 코드와 설정이 따로 존재해 중복과 불일치 발생 가능

---

## 2. 어노테이션 기반 의존성 주입

* **무엇인가?**
  자바 코드 내에 `@Autowired`, `@Component` 같은 어노테이션을 붙여 직접 의존성을 선언하는 방식으로, 스프링이 자동으로 빈을 탐색하고 주입함.

* **특징**

  * 설정(XML)이 거의 필요 없고, 자바 클래스 위에 어노테이션으로 표시
  * 컴포넌트 스캔을 통해 자동으로 빈을 찾고 생성
  * 타입 기반 주입으로 명시적인 의존성 연결을 줄임
  * 생성자, 세터, 필드 등 다양한 방법으로 주입 가능
  * 코드와 설정이 통합돼 있어 관리가 쉽고 직관적임

* **장점**

  * 설정 작업과 XML 관리가 크게 줄어 개발 생산성 향상
  * 의존성 관계가 코드 바로 위에 있어 이해와 유지보수가 쉬움
  * 자동 주입으로 개발 편의성 극대화

* **단점**

  * 대규모 프로젝트에서 의존성 흐름이 코드에 분산될 수 있어 전체 구조 파악이 어려울 수 있음
  * 자동 주입으로 인해 어떤 빈이 주입되는지 애매해질 수 있음 (특히 동일 타입 빈 여러 개 존재 시)
  * 컴파일 타임이 아닌 런타임 시에 문제 발견 가능 (빈 누락 등)

---

## 간단 비교표

| 구분        | XML 기반 DI       | 어노테이션 기반 DI                |
| --------- | --------------- | -------------------------- |
| 의존성 설정 위치 | 외부 XML 파일       | 자바 코드 내부 어노테이션             |
| 주입 방식     | 명시적 생성자/세터 주입   | 자동 타입 주입 (생성자/세터/필드)       |
| 관리 편의성    | 설정 집중, 변경 용이    | 코드와 설정 통합, 직관적             |
| 복잡성       | XML 복잡해질 수 있음   | 코드 분산으로 대규모 시 복잡해질 수 있음    |
| 유연성       | 환경별 설정 변경 쉽고 명확 | 자동 주입으로 간결하지만 변경시 코드 수정 필요 |

---
📅[목차로 돌아가기](#-목차)

# 2025-07-22

---

## 1. 어노테이션 기반 의존성 주입 (Dependency Injection)

* **무엇인가?**
  자바 클래스에 어노테이션을 붙여 스프링이 자동으로 빈을 등록하고 의존성을 주입하는 방식.

* **특징**

  * XML 설정을 거의 사용하지 않고, 코드 안에 어노테이션으로 빈과 의존 관계 선언
  * `@Component`, `@Controller`, `@Service`, `@Repository` 등으로 빈 등록
  * `@Autowired`로 타입에 맞는 빈을 자동 주입
  * `@Qualifier`를 사용해 동일 타입 빈 중 특정 빈 지정 가능
  * `@Configuration`, `@ComponentScan`, `@ImportResource`, `@Bean` 등 자바 기반 설정 지원
  * 빈 스코프 지정 가능 (`singleton` 기본, `prototype` 등)

* **장점**

  * 설정과 코드가 통합되어 관리와 이해가 쉬움
  * 컴포넌트 스캔을 통해 자동으로 빈을 찾아서 등록하므로 편리함
  * 코드 작성량과 설정 작업이 크게 줄어 개발 생산성 향상

* **단점**

  * 대규모 프로젝트에서는 의존성 흐름이 코드에 분산되어 파악 어려울 수 있음
  * 자동 주입으로 어떤 빈이 주입되는지 모호해질 가능성 (특히 동일 타입 빈 여러 개일 때)
  * 런타임 시점에 의존성 문제 발생할 수 있음

---

## 2. Spring AOP (Aspect-Oriented Programming)

* **무엇인가?**
  핵심 비즈니스 로직과 공통 관심사를 분리하여 코드 중복을 줄이고 모듈화하는 프로그래밍 패러다임.

* **특징**

  * 공통 관심사(로깅, 트랜잭션 등)를 모듈화하여 핵심 관심사에서 분리
  * 핵심 로직(Target Object)에 Proxy를 씌워 부가 기능 수행
  * Aspect, Advice, Pointcut 등 여러 개념으로 동작 방식 명확히 정의
  * 런타임에 필요한 시점(JoinPoint)에 공통 기능을 삽입(Weaving)

* **주요 용어**

  | 용어            | 설명                                          |
  | ------------- | ------------------------------------------- |
  | Target Object | 부가기능이 적용될 실제 객체                             |
  | JoinPoint     | 부가기능을 적용할 수 있는 시점(메서드 실행 등)                 |
  | Pointcut      | JoinPoint 중 Advice가 적용될 위치 지정               |
  | Aspect        | 공통 관심사를 모듈화한 단위 (Advice + Pointcut)         |
  | Advice        | 공통 기능이 실제 동작하는 코드 (Before, After, Around 등) |
  | Weaving       | Aspect를 핵심 로직에 연결하는 과정                      |

* **장점**

  * 코드 중복 최소화 및 유지보수성 향상
  * 공통 기능 변경이 쉽고 핵심 로직에 영향 최소화
  * 선언적 트랜잭션 처리 등 다양한 기능 편리하게 구현 가능

* **단점**

  * AOP 동작 원리와 구조 이해에 시간 필요
  * 복잡한 설정이나 디버깅이 어려울 수 있음

---
📅[목차로 돌아가기](#-목차)


