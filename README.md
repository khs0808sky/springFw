# springFw

## 📅 목차

- [2025-07-21](#2025-07-21)
- [2025-07-22](#2025-07-22)
- [2025-07-23](#2025-07-23) 

<br><br><br>

# 2025-07-21
---

## 1. XML 기반 의존성 주입 (Dependency Injection)

* **무엇인가?**
  객체 간의 의존 관계를 XML 파일에 설정해두고, 스프링 컨테이너가 이를 읽어 필요한 객체를 생성하고 연결해 주는 방식.

* **특징**

  * 모든 의존 관계를 XML 설정 파일에서 선언적으로 관리
  * 객체 생성과 주입 방식을 모두 설정 파일에서 제어
  * 생성자 주입과 세터 주입을 명확히 구분해서 설정 가능
  * 설정과 코드가 분리되어 있어 설정 변경 시 코드 수정 없이 의존성 변경 가능
  * 다만 설정이 길어지면 XML이 복잡해지고 관리가 어려울 수 있음

* **장점**

  * 설정이 한 곳에 집중되어 있어 의존성 흐름 파악이 용이
  * 환경별, 배포별 설정 변경이 쉬움
  * XML 파일만 바꾸면 의존성 변경 가능 → 유연성 높음

* **단점**

  * XML 작성과 관리에 번거로움
  * 코드와 설정이 분리돼 있어 개발 중 이해가 어려울 수 있음
  * 자바 코드와 설정이 따로 존재해 중복과 불일치 발생 가능

---

## 2. 어노테이션 기반 의존성 주입

* **무엇인가?**
  자바 코드 내에 `@Autowired`, `@Component` 같은 어노테이션을 붙여 직접 의존성을 선언하는 방식으로, 스프링이 자동으로 빈을 탐색하고 주입함.

* **특징**

  * 설정(XML)이 거의 필요 없고, 자바 클래스 위에 어노테이션으로 표시
  * 컴포넌트 스캔을 통해 자동으로 빈을 찾고 생성
  * 타입 기반 주입으로 명시적인 의존성 연결을 줄임
  * 생성자, 세터, 필드 등 다양한 방법으로 주입 가능
  * 코드와 설정이 통합돼 있어 관리가 쉽고 직관적임

* **장점**

  * 설정 작업과 XML 관리가 크게 줄어 개발 생산성 향상
  * 의존성 관계가 코드 바로 위에 있어 이해와 유지보수가 쉬움
  * 자동 주입으로 개발 편의성 극대화

* **단점**

  * 대규모 프로젝트에서 의존성 흐름이 코드에 분산될 수 있어 전체 구조 파악이 어려울 수 있음
  * 자동 주입으로 인해 어떤 빈이 주입되는지 애매해질 수 있음 (특히 동일 타입 빈 여러 개 존재 시)
  * 컴파일 타임이 아닌 런타임 시에 문제 발견 가능 (빈 누락 등)

---

## 간단 비교표

| 구분        | XML 기반 DI       | 어노테이션 기반 DI                |
| --------- | --------------- | -------------------------- |
| 의존성 설정 위치 | 외부 XML 파일       | 자바 코드 내부 어노테이션             |
| 주입 방식     | 명시적 생성자/세터 주입   | 자동 타입 주입 (생성자/세터/필드)       |
| 관리 편의성    | 설정 집중, 변경 용이    | 코드와 설정 통합, 직관적             |
| 복잡성       | XML 복잡해질 수 있음   | 코드 분산으로 대규모 시 복잡해질 수 있음    |
| 유연성       | 환경별 설정 변경 쉽고 명확 | 자동 주입으로 간결하지만 변경시 코드 수정 필요 |

---

📅[목차로 돌아가기](#-목차)

---

# 2025-07-22

---

## 1. 어노테이션 기반 의존성 주입 (Dependency Injection)

* **무엇인가?**
  자바 클래스에 어노테이션을 붙여 스프링이 자동으로 빈을 등록하고 의존성을 주입하는 방식.

* **특징**

  * XML 설정을 거의 사용하지 않고, 코드 안에 어노테이션으로 빈과 의존 관계 선언
  * `@Component`, `@Controller`, `@Service`, `@Repository` 등으로 빈 등록
  * `@Autowired`로 타입에 맞는 빈을 자동 주입
  * `@Qualifier`를 사용해 동일 타입 빈 중 특정 빈 지정 가능
  * `@Configuration`, `@ComponentScan`, `@ImportResource`, `@Bean` 등 자바 기반 설정 지원
  * 빈 스코프 지정 가능 (`singleton` 기본, `prototype` 등)

* **장점**

  * 설정과 코드가 통합되어 관리와 이해가 쉬움
  * 컴포넌트 스캔을 통해 자동으로 빈을 찾아서 등록하므로 편리함
  * 코드 작성량과 설정 작업이 크게 줄어 개발 생산성 향상

* **단점**

  * 대규모 프로젝트에서는 의존성 흐름이 코드에 분산되어 파악 어려울 수 있음
  * 자동 주입으로 어떤 빈이 주입되는지 모호해질 가능성 (특히 동일 타입 빈 여러 개일 때)
  * 런타임 시점에 의존성 문제 발생할 수 있음

---

## 2. Spring AOP (Aspect-Oriented Programming)

* **무엇인가?**
  핵심 비즈니스 로직과 공통 관심사를 분리하여 코드 중복을 줄이고 모듈화하는 프로그래밍 패러다임.

* **특징**

  * 공통 관심사(로깅, 트랜잭션 등)를 모듈화하여 핵심 관심사에서 분리
  * 핵심 로직(Target Object)에 Proxy를 씌워 부가 기능 수행
  * Aspect, Advice, Pointcut 등 여러 개념으로 동작 방식 명확히 정의
  * 런타임에 필요한 시점(JoinPoint)에 공통 기능을 삽입(Weaving)

* **주요 용어**

  | 용어            | 설명                                          |
  | ------------- | ------------------------------------------- |
  | Target Object | 부가기능이 적용될 실제 객체                             |
  | JoinPoint     | 부가기능을 적용할 수 있는 시점(메서드 실행 등)                 |
  | Pointcut      | JoinPoint 중 Advice가 적용될 위치 지정               |
  | Aspect        | 공통 관심사를 모듈화한 단위 (Advice + Pointcut)         |
  | Advice        | 공통 기능이 실제 동작하는 코드 (Before, After, Around 등) |
  | Weaving       | Aspect를 핵심 로직에 연결하는 과정                      |

* **장점**

  * 코드 중복 최소화 및 유지보수성 향상
  * 공통 기능 변경이 쉽고 핵심 로직에 영향 최소화
  * 선언적 트랜잭션 처리 등 다양한 기능 편리하게 구현 가능

* **단점**

  * AOP 동작 원리와 구조 이해에 시간 필요
  * 복잡한 설정이나 디버깅이 어려울 수 있음

---

📅[목차로 돌아가기](#-목차)

---

# 2025-07-23

---

## 1. 어노테이션 기반 AOP (Aspect-Oriented Programming)

* **무엇인가?**
  XML 설정 없이 자바 어노테이션만으로 AOP 기능을 구현하는 방식으로, 핵심 로직에 부가기능을 선언적으로 적용할 수 있음.

* **특징**

  * `@Aspect`로 공통 기능 클래스를 정의
  * `@Before`, `@After`, `@Around` 등의 어드바이스(Advice) 어노테이션을 사용
  * `@Pointcut`으로 공통 기능이 적용될 위치(JoinPoint)를 명시
  * 설정 클래스에 `@EnableAspectJAutoProxy` 추가하여 AOP 활성화
  * 자바 코드 내에서 AOP 설정이 모두 가능해 관리가 간편

* **장점**

  * XML 없이 자바 코드로 모든 설정 가능
  * 가독성과 유지보수성이 높아짐
  * 스프링과 잘 통합되어 자동 주입 및 스캔과 연동 용이

* **단점**

  * AOP 동작 방식과 표현식을 정확히 이해하지 않으면 오작동 위험
  * Pointcut 표현식이 복잡할 수 있음

---

## 2. 포인트컷(Pointcut) 표현식

* **무엇인가?**
  Advice가 적용될 JoinPoint를 지정하기 위한 표현식 (메서드 기준으로 사용)

* **주요 형식 예시**

  ```
  execution(접근제어자 리턴타입 패키지명.클래스명.메서드명(파라미터))
  ```

* **예시 설명**

  ```java
  execution(* com.example.service.*.*(..))
  ```

  → `com.example.service` 패키지 내의 모든 클래스의 모든 메서드에 적용

* **표현식 패턴**

  | 패턴            | 의미                       |
  | ------------- | ------------------------ |
  | `*`           | 모든 값 (리턴타입, 메서드명 등에서 사용) |
  | `..`          | 0개 이상의 하위 패키지 또는 파라미터    |
  | `(..)`, `(*)` | 모든 파라미터, 또는 하나의 파라미터     |
  | 정확한 메서드명 지정   | 특정 메서드에만 적용              |

---

## 3. DB(Database, 데이터베이스)

* **무엇인가?**
  데이터를 효율적으로 저장, 관리, 검색할 수 있도록 구조화된 저장소

* **종류**

  * 관계형 DBMS: MySQL, Oracle, PostgreSQL 등
  * 비관계형(NoSQL): MongoDB, Redis 등

* **용도**

  * 사용자 정보, 게시글, 상품 정보 등 앱/웹 서비스의 핵심 데이터 저장
  * 데이터를 구조화하고 중복 없이 관리

---

## 4. JDBC (Java Database Connectivity)

* **무엇인가?**
  자바에서 DB와 연결해 SQL을 실행할 수 있도록 도와주는 API

* **동작 순서**

  1. 드라이버 로드 (`Class.forName(...)`)
  2. DB 연결 (`DriverManager.getConnection(...)`)
  3. SQL 실행 (`Statement` 또는 `PreparedStatement`)
  4. 결과 처리 (`ResultSet`)
  5. 연결 종료 (`close()`)

* **단점**

  * 반복 코드 많고, 예외 처리 복잡
  * 유지보수가 어려움
  * 그래서 Spring JDBC, JPA 등이 등장함

---

## 5. CRUD (Create, Read, Update, Delete)

* **무엇인가?**
  데이터베이스의 기본적인 4가지 작업 방식

| 작업     | 설명     | SQL 예시                     |
| ------ | ------ | -------------------------- |
| Create | 데이터 생성 | `INSERT INTO`              |
| Read   | 데이터 조회 | `SELECT`                   |
| Update | 데이터 수정 | `UPDATE ... SET ... WHERE` |
| Delete | 데이터 삭제 | `DELETE FROM ... WHERE`    |

---

📅[목차로 돌아가기](#-목차)

---

